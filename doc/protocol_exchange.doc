about the exchange of data between peer

opcode:

1xx : respond code
2xx : systeme code
3xx : push data code
4xx : pull data code

1xx
101 : connection ok

2xx
203 : signed message
280 : log off.

3xx
301 : push message. use to test the connection between peer.
302 : push the information about node connected to you.
303 : push disconnected peer.
305 : push a transaction with signature & without proof, asking for a proof and parity.
310 : push a transaction with signature & proof & parity.
320 : push a creation with signature.
350 : push your identity (public key).
352 : push your identity (port).
370 : push the current book.
371 : push the current list state.
390 : push a user balance

4xx
402 : ask for a 302 full response.
403 : ask for a 203 signed message.
405 : ask for a transaction to be signed.
470 : ask for the current book.
490 : ask for a user balance.




how to connect :
until you are connected to the peer, you cant send msg from the 3xx range.
to connect to a peer, you have to respond to the 403 opcode following the procedure :
-> : to peer
<- : from peer

<- 403, msg
-> 203, signed msg with your key
<- 101

you are now connected.
if the server doesnt send you a 403 message in first place, you can send a blanck opcode (001) to try and trigger it.




how to send data :
data format:
	the data packet is made of at least 3 field, serialized in JSON format :
		code: represente the opcode,
		data: data field formated for correctly for the opcode
		user: your public key,
		signature: RSA signature of the 3 field above in the algo : "{code:" + code + ",data:" + data + ",user:" + user + "}". needed in noneconnected protocole.




how to send currency as user (without book):
-> : to peer
<- : from peer

trans: transaction representing the sending
parity: transaction representing the parity.

-> 305 data:trans(unsigned, unproofed)
<- 405 data:{transaction: trans(unsigned), parity: parity(unsigned)}
-> 310 data:{transaction: trans(signed), parity: parity(signed)}




data formate :
101
data : no data

203
data : signature

280:
data: no data


301 :
data: msg.
msg : message to print. type: string

302:
data: serialized(ip + ":" + port + "/")
ip: ip of node. type: string
port: port of node. type: int

303:
data: serialized(ip + ":" + port)
ip: ip of node. type: string
port: port of node. type: int

305:
data: serialized(transaction)
transaction: transaction. type: transaction (see transaction section)

310:
data: serialized({
	transaction: transaction,
	parity: parity
})
transaction: transaction. type: transaction (see transaction section)
parity: parity to consume the proof. type: transaction (see transaction section)

320:
data: serialized(transaction)
transaction: transaction. type: transaction (see transaction section)

350:
data: key
key: public key. type: string

352:
data: port
port: port to reach you. type: int

370:
data: serialized(transaction + ";")
transaction: transaction. type: transaction (see transaction section)

371:
data: serialized({
	blacklist: bool,
	whitelist: bool,
	list: serialized(key + ";")
})
/!\ : whitelist have priority. if both blacklist and whitelist are true, the expected behavior is the same as if blacklist was false.

390:
data: balance
balance : balance of the user as. type : double;

402:
data: no data

401:
data: msg to sign

405:
data: serialized({
	transaction: transaction(unsigned),
	parity: parity(unsigned)
})
transaction: transaction. type: transaction (see transaction section)
parity: parity to consume the proof. type: transaction (see transaction section)

470:
data: no data

490:
data: key
key: key of the user from which to get the balance. type: string





transaction:
transaction represented by a json as follow:
{
	"amount": amount,
	"proof": proof,
	"sender": senderKey,
	"receiver": receiverKey,
	"sign": signature,
	"timestamp": timestamp
}
amount: amount of currency exchanged. type: double
proof: the signature of the prooving transaction. type: string
sender: the public key of the sender. type: string
receiver: the public key of the receiver. type: string
sign: signature generated by the serialized transaction with field : amount, proof, sender, receiver, timestamp. type: string
timestamp: unix timestamp at the moment of creation of the transaction. type: int

in this documentation, if specified as : "transaction(unsigned)", the transaction is unsigned and the field can be ommited in during exchange. if not specified, the transaction is assumed to be signed
in this documentation, if specified as : "transaction(unproofed)", the transaction is unproofed and the field can be ommited in during exchange. if not specified, the transaction is assumed to be proofed




key:
key are RSA key of 256 bytes serialized with the following algorithm :
	serialize(string((int)symbole) + " ")
	symbole: represent an atomic character of the key. type: char
